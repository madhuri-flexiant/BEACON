package com.flexiant;

import java.util.HashMap;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

/**
 * Class to process the requests from the queue.
 * @author mramannavar
 *
 */
public class ScanRequestProcessor {
	
	//private static ExecutorService socketThreads = Executors.newFixedThreadPool(10);
	private static Logger LOGGER = LogManager.getLogger(ScanRequestProcessor.class);
	private static BlockingQueue<HashMap<String, String>> queue = null;
	ExecutorService cachedPool = Executors.newCachedThreadPool();
	
	public ScanRequestProcessor(ArrayBlockingQueue<HashMap<String, String>> queue) {
		ScanRequestProcessor.queue = queue;
	}
		
	void processRequests() {		
		LOGGER.info("Processing of requests under progress...");
		
		while (true) {
			HashMap<String, String> request = retrieveRequest();
			if (null != request) {
				ExecuteScan scan = new ExecuteScan(request);
				cachedPool.submit(scan);
			}
		}
	}
	
	/**
	 * Retrieve the request from the Queue, max wait time for a request to be available is 1 minute.
	 * Request is null if the queue is empty
	 * @return request
	 */
	private HashMap<String, String> retrieveRequest() {
		HashMap<String, String> request = null;
		try {
			request = queue.poll(60, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			LOGGER.error("Failed to retrieve the request from the Queue", e);
		}
		return request;
	}
	
	public void shutdown() {
		
		try {
			cachedPool.shutdown();
			cachedPool.awaitTermination(5, TimeUnit.MINUTES);
		
			if (!cachedPool.isShutdown()) {
				cachedPool.shutdownNow();
			}
		} catch (InterruptedException e) {
			LOGGER.error("The CachedPool was interrupted while being shut.", e);
		}
	}
}
