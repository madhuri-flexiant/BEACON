package com.flexiant;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

/**
 * Class to process the requests from the queue.
 * @author mramannavar
 *
 */
public class ScanRequestProcessor {
	
	//private static ExecutorService socketThreads = Executors.newFixedThreadPool(10);
	private static Logger LOGGER = LogManager.getLogger(ScanRequestProcessor.class);
	private static BlockingQueue<Request> queue = null;
	ExecutorService cachedPool = Executors.newCachedThreadPool(); // set a value
	
	public ScanRequestProcessor(ArrayBlockingQueue<Request> queue) {
		ScanRequestProcessor.queue = queue;
	}
		
	void processRequests() {		
		LOGGER.info("Processing of requests under progress...");
		
		while (true) {
			Request request = retrieveRequest();
			if (null != request) {
				LOGGER.info("Submitting a request...");
				ExecuteScan scan = new ExecuteScan(request);
				cachedPool.submit(scan);
			}
		}
	}
	
	/**
	 * Retrieve the request from the Queue, max wait time for a request to be available is 1 minute.
	 * Request is null if the queue is empty
	 * @return request
	 */
	private Request retrieveRequest() {
		Request request = null;
		try {
			LOGGER.info("Retrieving a request...");
			request = queue.poll(60, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			LOGGER.error("Failed to retrieve the request from the Queue", e);
		}
		return request;
	}
	
	public void shutdown() {
		
		try {
			cachedPool.shutdown();
			
			while(!cachedPool.awaitTermination(60, TimeUnit.SECONDS)) {
				LOGGER.info("Awaiting for the threads to finish ...");
			}
			
			if (!cachedPool.isTerminated()) {
				cachedPool.shutdownNow();
			}
		} catch (InterruptedException e) {
			LOGGER.error("The CachedPool was interrupted while being shut.", e);
		}
	}
}
