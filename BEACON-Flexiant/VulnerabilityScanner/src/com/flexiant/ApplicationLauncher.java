package com.flexiant;

import java.util.HashMap;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

/**
 * As the name suggests this class launches the Application.
 * Instantiates the Log4j2 and spawns threads to listen to socket continuously. 
 * Starts the ScanRequestProcessor to process the requests.  
 * @author mramannavar
 *
 */

public class ApplicationLauncher {
	
	private static Logger LOGGER = LogManager.getLogger(ApplicationLauncher.class);
//	private static String configFile = "log4j2.xml";
    
	// Once the project is being used by the other partners, the queue length will be increased.
    private static int MAX_QUEUE_LENGTH = 15;
    private static int PORT1 = 8341;
    private static int PORT2 = 8342;
    private static int PORT3 = 8343;
    
	private static ArrayBlockingQueue<HashMap<String, String>> queue = null; 
	private static ExecutorService socketThreads = null;
	
	// The Log4j2 config xml file is automatically found if placed in the src folder but if something goes wrong
	// use the code below to locate the config file.
//	static {
//		String log4jConfigFile = System.getProperty("user.dir") + File.separator + configFile;
//    	System.out.println("User.dir:" + System.getProperty("user.dir"));
//    	ConfigurationSource source;
//		try {
//			source = new ConfigurationSource(new FileInputStream(log4jConfigFile));
//			Configurator.initialize(null, source);
//		} catch (FileNotFoundException e) {
//			LOGGER.error("Logging configuration file was not found", e);
//		} catch (IOException e) {
//			LOGGER.error("Error - when trying to obtain the logging configuration file", e);
//		}
//	}
   
	public static void main(String[] args) {
		queue = new ArrayBlockingQueue<HashMap<String, String>>(MAX_QUEUE_LENGTH);
		socketThreads = Executors.newFixedThreadPool(3);
		
		LOGGER.debug("The runnables being submitted, ready to read from the socket");
	    socketThreads.submit(new SocketListener(PORT1, queue));
	    socketThreads.submit(new SocketListener(PORT2, queue));
	    socketThreads.submit(new SocketListener(PORT3, queue));
	    
	    LOGGER.info("Launching the a RequestProcessor..."); 
	    
	    ScanRequestProcessor processor = new ScanRequestProcessor(queue);
	    processor.processRequests();
	    
        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
            	LOGGER.info("Application Terminated, shutdown hook called.");
            	shutdown();
            	processor.shutdown();
            }
        });
    }
	
	public static void shutdown() {
		try {
			socketThreads.shutdown();
			
			while(!socketThreads.awaitTermination(60, TimeUnit.SECONDS)) {
				LOGGER.info("Awaiting for the threads to finish ...");
			}
		
			if (!socketThreads.isTerminated()) {
				socketThreads.shutdownNow();
			}
		} catch (InterruptedException e) {
			LOGGER.error("The newFixedThreadPool was interrupted while being shut.", e);
		}
	}
}

